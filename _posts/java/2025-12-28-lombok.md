---
layout: post
title: "Lombok - Java Boilerplate 코드 제거 라이브러리"
date: 2025-12-28
categories: [java, library]
tags: [lombok, java, boilerplate, annotation]
---

Lombok은 Java에서 반복적인 boilerplate 코드를 어노테이션으로 자동 생성해주는 라이브러리입니다.

## 공식 문서

- [Lombok Features](https://projectlombok.org/features/all)

## @Getter / @Setter

필드에 대한 getter와 setter 메서드를 자동 생성합니다.

```java
public class GetterSetterExample {
  /**
   * Age of the person. Water is wet.
   *
   * @param age New value for this person's age. Sky is blue.
   * @return The current value of this person's age. Circles are round.
   */
  @Getter @Setter private int age = 10;

  /**
   * Name of the person.
   * -- SETTER --
   * Changes the name of this person.
   *
   * @param name The new value.
   */
  @Setter(AccessLevel.PROTECTED) private String name;

  @Override public String toString() {
    return String.format("%s (age: %d)", name, age);
  }
}
```

위 코드는 다음과 같이 변환됩니다:

```java
public class GetterSetterExample {
  private int age = 10;
  private String name;

  @Override public String toString() {
    return String.format("%s (age: %d)", name, age);
  }

  public int getAge() {
    return age;
  }

  public void setAge(int age) {
    this.age = age;
  }

  protected void setName(String name) {
    this.name = name;
  }
}
```

## @Data

`@ToString`, `@EqualsAndHashCode`, 모든 필드에 `@Getter`, non-final 필드에 `@Setter`, `@RequiredArgsConstructor`를 한번에 적용합니다.

```java
@Data
public class User {
    private String name;
    private int age;
}
```

- [@Data 공식 문서](https://projectlombok.org/features/Data)

## @Value

`@Data`의 불변(immutable) 버전입니다. 모든 필드가 private final로 설정되고 setter는 생성되지 않습니다.

- [@Value 공식 문서](https://projectlombok.org/features/Value)

## @Builder

빌더 패턴을 자동으로 구현해줍니다.

```java
@Builder
public class User {
    private String name;
    private int age;
}

// 사용법
User user = User.builder()
    .name("John")
    .age(25)
    .build();
```

- [@Builder 공식 문서](https://projectlombok.org/features/Builder)

## @NonNull

파라미터나 필드에 null 체크를 자동으로 추가합니다.

```java
public NonNullExample(@NonNull Person person) {
    super("Hello");
    this.name = person.getName();
}
```

위 코드는 다음과 같이 변환됩니다:

```java
public NonNullExample(@NonNull Person person) {
    super("Hello");
    if (person == null) {
      throw new NullPointerException("person");
    }
    this.name = person.getName();
}
```

## @Cleanup

리소스의 자동 정리(close)를 보장합니다.

```java
public static void main(String[] args) throws IOException {
    @Cleanup InputStream in = new FileInputStream(args[0]);
    @Cleanup OutputStream out = new FileOutputStream(args[1]);
    byte[] b = new byte[10000];
    while (true) {
      int r = in.read(b);
      if (r == -1) break;
      out.write(b, 0, r);
    }
}
```

위 코드는 try-finally 블록으로 변환되어 리소스가 안전하게 닫힙니다.

## @SneakyThrows

checked exception을 unchecked처럼 던질 수 있게 해줍니다.

사용 케이스:
- 예외가 발생할 가능성이 없는 경우
- Runnable 등에서 예외 처리가 필요한 경우

## @Slf4j (로깅)

로거를 자동으로 생성합니다.

```java
@Slf4j
public class LogExample {
}
```

위 코드는 다음과 같이 변환됩니다:

```java
public class LogExample {
    private static final org.slf4j.Logger log = org.slf4j.LoggerFactory.getLogger(LogExample.class);
}
```

## @ToString

toString() 메서드를 자동 생성합니다.

- [@ToString 공식 문서](https://projectlombok.org/features/ToString)

## @EqualsAndHashCode

equals()와 hashCode() 메서드를 자동 생성합니다.

- [@EqualsAndHashCode 공식 문서](https://projectlombok.org/features/EqualsAndHashCode)

## @RequiredArgsConstructor

final 필드나 @NonNull 필드를 파라미터로 받는 생성자를 생성합니다.

- [@Constructor 공식 문서](https://projectlombok.org/features/constructor)

## @Getter(lazy=true)

지연 초기화되는 getter를 생성합니다.

## val

타입을 생략하고 final로 선언합니다.

```java
val example = new ArrayList<String>();
// 위는 아래와 같습니다
final ArrayList<String> example = new ArrayList<String>();
```
